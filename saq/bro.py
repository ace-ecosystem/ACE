# vim: sw=4:ts=4:et:cc=120

import os.path
import re
import logging
import collections
import datetime

# regular expressions for parsing smtp files generated by bro extraction (see bro/ directory)
REGEX_BRO_SMTP_SOURCE_IPV4 = re.compile(r'^([^:]+):(\d+).*$')
REGEX_BRO_SMTP_MAIL_FROM = re.compile(r'^> MAIL FROM:<([^>]+)>.*$')
REGEX_BRO_SMTP_RCPT_TO = re.compile(r'^> RCPT TO:<([^>]+)>.*$')
REGEX_BRO_SMTP_DATA = re.compile(r'^< DATA 354.*$')
REGEX_BRO_SMTP_RSET = re.compile(r'^< RSET.*$')

RFC822Email = collections.namedtuple('RFC822Email', [
    'source_ipv4', 
    'source_port',
    'envelope_from',
    'envelope_to',
    'received',
    'file_path'])

def parse_bro_smtp(smtp_path, target_dir, prefix='smtp'):
    """Parses a SMTP file generated by bro/ace_smtp.zeek returning a list of generated RFC 822 formatted files.

    Args:
        smtp_path: Path to the SMTP file to parse.
        target_dir: Directory to place the RFC822 formatted email files into.
        prefix: Optional prefix for the names of the email files. The name of each file has the following format:
            prefix.index.email.rfc822
            where prefix is this parameter (defaults to 'smtp')
            index is the zero-based index of the email inside of the stream data

    Returns:
        Yields RFC822Email objects for each parsed email.
    """

    # the current message we're parsing in the case of multiple emails coming in over the same connection
    smtp_message_index = 0 

    with open(smtp_path, 'r', errors='ignore') as fp:
        source_ipv4 = None
        source_port = None
        envelope_from = None
        envelope_to = []

        # the first line of the file has the source IP address of the smtp connection
        # in the following format: 172.16.139.143:38668/tcp

        line = fp.readline()
        m = REGEX_BRO_SMTP_SOURCE_IPV4.match(line)

        if not m:
            raise ValueError("unable to parse soure address from {} ({})".format(smtp_path, line.strip()))
        else:
            source_ipv4 = m.group(1)
            source_port = m.group(2)

            logging.debug("got source ipv4 {} port {} for {}".format(source_ipv4, source_port, smtp_path))

        # the second line is the time (in epoch UTC) that bro received the file
        line = fp.readline()
        event_time = datetime.datetime.utcfromtimestamp(int(line.strip()))
        logging.debug("got event time {} for {}".format(event_time, smtp_path))

        STATE_SMTP = 1
        STATE_DATA = 2

        state = STATE_SMTP
        rfc822_path = None
        rfc822_fp = None

        def _reset_state():
            nonlocal rfc822_fp, source_ipv4, source_port, envelope_from, envelope_to, state
            rfc822_fp = None
            #source_ipv4 = None
            #source_port = None
            envelope_from = None
            envelope_to = []
            state = STATE_SMTP

        def _finalize():
            # called when we detect the end of an SMTP stream OR the end of the file (data)
            nonlocal rfc822_fp, source_ipv4, source_port, envelope_from, envelope_to, state
            rfc822_fp.close()
            logging.info("finished parsing {} from {}".format(rfc822_path, smtp_path))
            result = RFC822Email(
                    source_ipv4=source_ipv4,
                    source_port=source_port,
                    envelope_from=envelope_from,
                    envelope_to=envelope_to,
                    received=event_time,
                    file_path=rfc822_path)
            _reset_state()
            return result

        # smtp is pretty much line oriented
        while True:
            line = fp.readline()
            if line == '':
                break

            if state == STATE_SMTP:
                m = REGEX_BRO_SMTP_MAIL_FROM.match(line)
                if m:
                    envelope_from = m.group(1)
                    logging.debug("got envelope_from {} for {}".format(envelope_from, smtp_path))
                    continue

                m = REGEX_BRO_SMTP_RCPT_TO.match(line)
                if m:
                    envelope_to.append(m.group(1))
                    logging.debug("got envelope_to {} for {}".format(envelope_to, smtp_path))
                    continue

                m = REGEX_BRO_SMTP_DATA.match(line)
                if m:
                    state = STATE_DATA
                    rfc822_path = os.path.join(target_dir, f'{prefix}.{smtp_message_index}.email.rfc822')
                    smtp_message_index += 1
                    rfc822_fp = open(rfc822_path, 'w')
                    logging.debug("created {} for {}".format(rfc822_path, smtp_path))
                    continue

                m = REGEX_BRO_SMTP_RSET.match(line)
                if m:
                    logging.debug(f"detected RSET for {smtp_path}")
                    _reset_state()
                    continue

                # any other command we skip
                logging.debug(f"skipping SMTP command {line.strip()}")
                continue

            # otherwise we're reading DATA and looking for the end of that
            if line.strip() == ('> . .'):
                yield _finalize()
                continue

            rfc822_fp.write(line)
            continue

        # did the file end while we were reading SMTP data?
        if state == STATE_DATA:
            yield _finalize()
